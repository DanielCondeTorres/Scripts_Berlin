                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    209,1         87import MDAnalysis as mda
import argparse
import matplotlib.pyplot as plt
import numpy as np
import mdtraj as md
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
# Agregar argumentos para los archivos de entrada
parser = argparse.ArgumentParser(description='Script que procesa archivos de entrada')

parser.add_argument('-f', '--pdb', required=True, help='Ruta del archivo .pdb')

parser.add_argument('-m', '--map', required=True, help='Ruta del archivo .map')

parser.add_argument('-x', '--xtc', required=False, help='Ruta del archivo .xtc')

parser.add_argument('-d', '--dcd', required=False, help='Ruta del archivo .dcd')
# Leer los argumentos de la línea de comandos
args = parser.parse_args()
# Archivos para almacenar
#pdb_writer = md.formats.PDBTrajectoryFile('coordinadas_transformadas.pdb', mode='w', force_overwrite=True)
# Acceder a los archivos de entrada

archivo_pdb = args.pdb
archivo_map = args.map
archivo_xtc = args.xtc
archivo_dcd = args.dcd


#Funciones:
def escribir_pdb(coordenadas, nombres, nombre_archivo="nuevas_coordenadas.pdb"):
    with open(nombre_archivo, "w") as archivo_pdb:
        archivo_pdb.write("HEADER    GENERATED BY PYTHON\n")
        for i, (x, y, z) in enumerate(coordenadas, start=1):
            nombre_atomo = nombres[i - 1] if i <= len(nombres) else "W"
            linea = f"ATOM  {i:5}  {nombre_atomo:3} MOL     1    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00\n"
            archivo_pdb.write(linea)
        archivo_pdb.write("END\n")




def escribir_xyz(coordenadas, nombres, nombre_archivo="nuevas_coordenadas.xyz"):
    with open(nombre_archivo, "a") as archivo:
        n_atomos = len(coordenadas)
        archivo.write(f"{n_atomos}\n")
        archivo.write("Coordenadas generadas con Python\n")
        for i, (x, y, z) in enumerate(coordenadas):
            nombre_atomo = nombres[i] if i < len(nombres) else "W"
            archivo.write(f"{nombre_atomo} {x:12.6f} {y:12.6f} {z:12.6f}\n")

#
# Lee el archivo de texto
with open(archivo_map, 'r') as file:
    lines = file.readlines()


# Inicializa listas vacías para almacenar los resultados
martini_list = []
atoms_list_2columns = []
atoms_list_3columns = []

# Itera sobre las líneas del archivo
in_martini_section = False
in_atoms_section = False

# Itera sobre las líneas del archivo
for i, line in enumerate(lines):
    # Verifica si estamos dentro de la sección [martini]
    if line.strip() == '[ martini ]':
        in_martini_section = True
        continue
    elif in_martini_section and line.startswith('['):
        in_martini_section = False

    # Verifica si estamos dentro de la sección [atoms]
    if line.strip() == '[ atoms ]':
        in_atoms_section = True
        continue
    elif in_atoms_section and line.startswith('['):
        in_atoms_section = False

    # Procesa las líneas según la sección actual
    if in_martini_section and line.strip():
        martini_list.extend(line.strip().split())
    elif in_atoms_section and line.strip():
        columns = line.split()
        atoms_list_3columns.append(columns[1:])


# Imprime los resultados
print("Martini List:", martini_list)
# Crear el diccionario
output_dict = {item[0]: item[1:] for item in atoms_list_3columns if item}

# Imprimir el diccionario

mass = {'H': 1,'C': 12,'N': 14,'O': 16,'S': 32,'P': 31,'M': 0, 'B': 32}
# Nuevo diccionario con los valores numéricos añadidos
nuevo_diccionario = {}

for clave, valor in output_dict.items():
    for letra, masa in mass.items():
        if clave.startswith(letra):
            nuevo_diccionario[clave] = valor + [masa]
            break  # Rompemos el bucle una vez que encontramos la letra correspondiente

# Imprimir el nuevo diccionario
print('Diccionario: ', nuevo_diccionario)


# Display all keys in the dictionary
all_keys = output_dict.keys()

# Convert the view object to a list if needed
elements = list(all_keys)


#

#Leemos el sistema:
system=mda.Universe(archivo_pdb)
seleccion_popc = system.select_atoms("resname POP")
numero_lipidos_popc = len(set(seleccion_popc.resids))
print('Tamaño : ',numero_lipidos_popc)
if archivo_xtc != None:
    system=mda.Universe(archivo_pdb,archivo_xtc)
#mdtraj
#traj = md.load_dcd(archivo_dcd, top=archivo_pdb)
if archivo_dcd != None:
    traj = md.load(archivo_dcd, top=archivo_pdb)
else:
    traj=md.load(archivo_pdb, top=archivo_pdb)
print(traj)
topology = traj.topology
membrane = topology.select("resname POP or resname POPC or resname POPE or resname POPS or resname CHOL")
#Atoms names:
# Obtener los nombres de los átomos en la selección
membrane_selection = membrane
# Imprimir los nombres de los átomos
membrane_selection = topology.select("resname POP or resname POPC or resname POPE or resname POPS or resname CHOL")
# Obtener los nombres de los átomos en la selección
atom_names = [topology.atom(i).name for i in membrane_selection]
#print(atom_names)
#Por desgracia, creo que voy a tener que definir el lipido, empezamos a mano...:
# Your list of elements

# Create an empty dictionary to store the results
result_dict = {}
#elements= ['O','H1','H2']
# Loop through each element and apply the topology.select() method
for element in elements:
    result_dict[f'{element}_lipid'] = topology.select(f'name {element}')

#Fin definicion lipido

print('END')
################################################################################
water = topology.select("resname SOL or resname W or resname HOH or resname WAT")
number_of_waters = int(len(water)/3)
OH = topology.select('name O')
H1 = topology.select('name H1')
H2 = topology.select('name H2')
print('Water atoms: ',water, 'Number of waters: ',int(len(water)/3))
ions = topology.select("symbol == K or symbol == Cl")
ions_positive = topology.select("symbol == K")
ions_negative = topology.select("symbol == Cl")
print('Ions atoms: ',ions)

#Mapeado agua:
mapping_water = np.array([16./18., 1./18., 1./18.])
#coordenadas agua por frame:
water_selection = water
for frame in range(traj.n_frames):
    print(f'Procesando frame {frame + 1}:')
    # Iterar a través de las moléculas de agua
    # Obtener las coordenadas de la molécula de agua seleccionada para el frame actual
    ############################################################
    ####################Water transformation####################
    ############################################################
    #water_coordinates = traj.xyz[frame, water_selection]

    if not water:
        cg_coordinates = np.zeros((number_of_waters, 3))
        nombres_coordenadas = []
    else:
        O_coordinates = traj.xyz[frame, OH]
        H1_coordinates = traj.xyz[frame, H1]
        H2_coordinates = traj.xyz[frame, H2]
        matrices = [O_coordinates, H1_coordinates, H2_coordinates]
        water_coordinates = np.vstack(np.column_stack(matrices).reshape(-1, matrices[0].shape[1]))

        #Correccion:
        R_split = np.split(water_coordinates,number_of_waters)
        R_stack = np.block(R_split)
        cg_coordinates = np.matmul(mapping_water,R_stack).reshape((number_of_waters,3))
        nombres_coordenadas_agua = ['W']
        nombres_coordenadas = nombres_coordenadas_agua*len(cg_coordinates)
    if not ions:
        print('No iones')
    else:
    ############################################################
    ####################Ions transformation####################
    ############################################################
        positive_ions_coordinates = traj.xyz[frame, ions_positive]

        negative_ions_coordinates = traj.xyz[frame, ions_negative]
        nombre_coordenadas_iones_positvos = ['K']*len(positive_ions_coordinates)
        nombre_coordenadas_iones_negativos = ['Cl']*len(negative_ions_coordinates)
        nombres_coordenadas.extend(nombre_coordenadas_iones_positvos)
        nombres_coordenadas.extend(nombre_coordenadas_iones_negativos)
        cg_coordinates = np.vstack([cg_coordinates, positive_ions_coordinates])
        cg_coordinates = np.vstack([cg_coordinates, negative_ions_coordinates])



    ############################################################
    ####################Membrane transformation####################
    ############################################################
    # Create an empty list to store the matrices
    matrices = []

    # Loop through each element in the result_dict
    for element_key, indices in result_dict.items():
        #print('INDICE :',indices,'Elemento : ', element_key)
        # Extract the coordinates for the current element
        element_coordinates = traj.xyz[frame, indices]
    
        # Append the coordinates to the list
        matrices.append(element_coordinates)

        # Now, matrices is a list containing NumPy arrays for each element's coordinates

    # Concatenate all the matrices along the last axis (axis=2)
    lipid_coordinates = np.vstack(np.column_stack(matrices).reshape(-1, matrices[0].shape[1]))
    
    R_split = np.split(lipid_coordinates,numero_lipidos_popc)
    R_stack = np.block(R_split)
    #print('Shape: ',R_stack.shape)
    for elemento in martini_list:
        sumatorio = []
#    seleccionados = {clave: valor for clave, valor in nuevo_diccionario.items() if elemento in valor}
        for clave, valor in nuevo_diccionario.items():
            letra_inicial = clave[0]
            valor_numerico = mass.get(letra_inicial, 0)
            count_nc3 = valor.count(elemento)
            size_lista = len(valor) - 1
            print('Valor: ',valor_numerico)
            print('Size: ',size_lista,'Clave: ',clave)
            if size_lista == 0:
                resultados = 0
                sumatorio.append(resultados)
            else:
                resultados= count_nc3 * valor_numerico/size_lista
                sumatorio.append(resultados)
            #print('Elemento: ',elemento, 'Res: ',resultados, 'Cuenta: ',count_nc3, 'Value: ',valor_numerico,'Tamaño lista: ',size_lista )
        #print('Suma Total: ', sum(sumatorio), 'del elemento: ',elemento)
        mapping_matrix_lipid = np.array(sumatorio)/sum(sumatorio)
        #print('Elemento: ',elemento, 'con matrix Mapping: ', np.array(sumatorio)/sum(sumatorio))

        cg_coordinates_lipids = np.matmul(mapping_matrix_lipid,R_stack).reshape((numero_lipidos_popc,3))
        nombres_coordenadas_elemento = [elemento]
        #print('Elemento: ',nombres_coordenadas_elemento)
        nombres_coordenadas_lipido = nombres_coordenadas_elemento*len(cg_coordinates_lipids)
        
        nombres_coordenadas.extend(nombres_coordenadas_lipido)
        cg_coordinates = np.vstack([cg_coordinates, cg_coordinates_lipids])

    ############################################################

    # Escribir las coordenadas transformadas en el archivo DCD
    #dcd_writer.write(cg_coordinates_3d)
    if frame == 0:
        escribir_pdb(cg_coordinates*10,nombres_coordenadas)
    escribir_xyz(cg_coordinates*10,nombres_coordenadas)
        #print(cg_coordinates,nombres_coordenadas)
    if frame == 10:
        break
    
'''
fig = plt.figure(figsize=(8,7))

ax = fig.add_subplot(111, projection='3d')

ax.view_init(30, 75)

R_CG= cg_coordinates
ax.scatter(R_CG[:,0], R_CG[:,1], R_CG[:,2], s=500, c=[[0,0,1,0.2]], depthshade=False)

R_AA = water_coordinates
R_O, R_H1, R_H2 = R_AA[0::3,:], R_AA[1::3,:], R_AA[2::3,:]

ax.scatter(R_O[:,0], R_O[:,1], R_O[:,2], s=20, c="red", depthshade=False)

ax.scatter(R_H1[:,0], R_H1[:,1], R_H1[:,2], s=10, c="green", depthshade=False)

ax.scatter(R_H2[:,0], R_H2[:,1], R_H2[:,2], s=10, c="green", depthshade=False)
#plt.show()


'''

#Save trayectory as .dcd
a=md.load('nuevas_coordenadas.xyz', top='nuevas_coordenadas.pdb')
# Guardar la trayectoria en un archivo DCD
a.save_dcd('nueva_trayectoria_a.dcd')
print("Martini List:", martini_list)
